###############################################################################
#                                                                             #
#                                                       11/Jan/2011  14:44:09 #
# IAR C/C++ Compiler V5.10.6.40180/W32, Kickstart LMS edition for MSP430      #
# Copyright 1996-2010 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430                                                     #
#    Source file   =  E:\various\_PW\TM\Lab_SVN\Lab5\IAR MSP430 files\main.c  #
#    Command line  =  "E:\various\_PW\TM\Lab_SVN\Lab5\IAR MSP430              #
#                     files\main.c" -lcN "E:\various\_PW\TM\Lab_SVN\Lab5\IAR  #
#                     MSP430 files\Debug\List\" -o                            #
#                     "E:\various\_PW\TM\Lab_SVN\Lab5\IAR MSP430              #
#                     files\Debug\Obj\" --no_cse --no_unroll --no_inline      #
#                     --no_code_motion --no_tbaa --debug -D__MSP430F149__ -e  #
#                     --dlib_config "C:\Program Files (x86)\IAR               #
#                     Systems\Embedded Workbench 6.0                          #
#                     Kickstart\430\LIB\DLIB\dl430fn.h" -Ol                   #
#    List file     =  E:\various\_PW\TM\Lab_SVN\Lab5\IAR MSP430               #
#                     files\Debug\List\main.lst                               #
#    Object file   =  E:\various\_PW\TM\Lab_SVN\Lab5\IAR MSP430               #
#                     files\Debug\Obj\main.r43                                #
#                                                                             #
#                                                                             #
###############################################################################

E:\various\_PW\TM\Lab_SVN\Lab5\IAR MSP430 files\main.c
      1          
      2          #include "io430x16x.h"   
      3          #include "intrinsics.h"
      4          #include "string.h"         // memset
      5          
      6          #define BAUDRATE 115200     // baud. zejscie ponizej 31250 wymusza
      7                                      // wyliczanie U0BR1
      8          
      9          #define ACLK_FQ 8000000     // Hz
     10          #define BUF_SIZE 32         // rozmiar bufora
     11          
     12          //timeout odbioru danych, pozwala stwierdzic koniec odbioru
     13          const int receive_timeout = ACLK_FQ / BAUDRATE * 10;
     14          char g_r_char = '0';        // bufor receive do przekazywania pojedynczego znaku
     15          char *g_t_curr_char = NULL; // wskaznik nastepnego znaku do wyslania przez trans
     16          int g_t_chars_to_send = 0;  // ilosc znakow pozostala do wyslania przez trans
     17          
     18          /* znaczniki przekazywane miedzy ISR a petla glowna
     19          b0 = przerwanie receive zglosilo nowy znak w g_r_char;
     20          b1 = przerwanie zauwazylo, ze aplikacja nie wyczyscila b0 - nie nadazyla
     21               z odebraniem danej z bufora g_r_char
     22          b4 = przerwanie transmit zglosilo gotowosc do wyslania nowego tekstu
     23          b5 = przerwanie timerA zglosilo timeout 
     24          */
     25          int g_flags = 0;            
     26          
     27          int main( void )
     28          {
     29            
     30            // bufory I/O
     31            char buffer[BUF_SIZE];
     32            char *err_buf = "MSP-ERROR: device reset.";
     33            const int err_buf_size = strlen(err_buf);
     34            char i_char;                  // tymczasowy char do przechowania znaku
     35          
     36            int r_buf_pos = BUF_SIZE - 1; // pozycja kursora w buforze receive
     37            int receive_on = 0;           // jestesmy w trakcie odbioru wiersza
     38            int transmit_on = 0;
     39            int ready_to_transmit = 0;    // istnieja dane gotowe do przeslania
     40            
     41            // Stop watchdog timer to prevent time out reset.
     42            WDTCTL = WDTPW + WDTHOLD;
     43            
     44            // wyzerowanie bufora I/O
     45            memset(buffer, 0, BUF_SIZE);
     46            BCSCTL1 &= !BIT0;            // wlaczenie XT2 (XT2OFF = 0)
     47            BCSCTL1 |= RSEL0 + RSEL1 + RSEL2;
     48            
     49            /*
     50            Przygotowanie zegarów.
     51            */
     52            //BCSCTL1 |= XTS;               // prze³¹czenie LFXT1 na HF (ACLK)
     53            //BCSCTL2 |= SELM1;             // MCLK = present(XT2) ? XT2 : LFXT1;
     54             
     55            BCSCTL2 |= SELS;                // SMCLK = XT2 jesli obecny
     56            
     57            /*
     58            Ustawienie portów:
     59            P1.7 - dioda b³êdu
     60            P3.4 - UTXD0
     61            P3.5 - URXD0
     62            */  
     63            P1OUT &= !BIT7;               // zgaszenie diody bledu 
     64            P1DIR |= BIT7;                // ustaw bit7 jako wyjsciowy
     65            P3SEL |= BIT4 + BIT5;         // ustaw piny do obslugi RS232
     66            P3DIR |= BIT4;        // ustaw pin 4 jako wyjscie :TODO: nie wiem czy potrzebne
     67            
     68            /*
     69            Przygotowanie timera A.
     70            Timer A slu¿y do wykrycia idle line po zakoñczeniu odbioru znaków z URXD.
     71            */
     72            TACTL |= 0x0200;              // wybranie SMCLK
     73            TACCR0 = receive_timeout; 
     74            
     75            /*
     76            Przygotowanie USART w trybie UART
     77            */
     78            U0CTL |= SWRST;
     79            U0CTL |= PENA  + PEV + SPB;   // :TODO:
     80            U0TCTL |= SSEL1;              // wybranie SMCLK
     81            U0RCTL |= URXEIE;
     82            //:TODO: ewentualne budzenie procesora na rising edge receive
     83            // ale nie potrzebujemy tego koniecznie, jesli nie wylaczymy zegara
     84            U0BR0 = ACLK_FQ / BAUDRATE;   // tylko jesli baudrate > 312500!
     85            U0BR1 = 0;
     86            U0MCTL = 0;
     87            ME1 = UTXE0 + URXE0;          // wlaczenie receive i transmit
     88            
     89            // ew. dalsza czesc inicjalizacji tutaj
     90            
     91            U0CTL &= !SWRST;              // wyzerowanie SWRST
     92            IE1 |= URXIE0;                // wlacz przerwania receive
     93          
     94            /***************** czêœæ aplikacyjna *****************/
     95          mainloop:
     96            while(1)
     97            {
     98              // Przejœcie w tryb uspienia + odlokowanie przerwañ
     99              __bis_SR_register(LPM0_bits + GIE);
    100              __no_operation();
    101              
    102              /***************** odebranie znaku *****************/
    103              TACCTL0 &= 0xFFEE;          // wylacz przerwania timeraA (CCIE, CCIFG)
    104              if (g_flags & BIT0)         // przerwanie receive zglasza dana do odebrania
    105              {
    106                /* sekcja krytyczna odczytu */
    107                __disable_interrupt();    
    108                  i_char = g_r_char;        // przepisanie znaku do bufora ap
    109                  g_flags &= !BIT0;         // wyczyszczenie znacznika oczekujacej danej
    110                  TACTL &= 0xFFCF;          // wylacz timerA
    111                  TACCR0 = TAR + receive_timeout; // zapewnij przerwanie po rec_timeout
    112                __enable_interrupt();
    113                /* koniec sekcji krytycznej odczytu */
    114                
    115                // jesli aplikacja nie nadaza z odbieraniem danych od przerwania, blad
    116                if (g_flags & BIT1)
    117                  goto error;      
    118                if (transmit_on == 1)     // nie mo¿e jednoczeœnie odbieraæ i wysy³aæ
    119                  goto error;
    120                if (receive_on == 0)      // jest to poczatek odbierania
    121                { 
    122                  receive_on = 1;
    123                  TACCR0 = receive_timeout; // zresetuj timer
    124                  TAR = 0;
    125                  TACCTL0 |= CCIE;        // wlacz przerwania
    126                  TACTL |= MC_2;          // continous mode on
    127                }
    128                
    129                if (i_char == 10)         //10 = LF 13 = CR koniec odbioru
    130                {
    131                  receive_on = 0;         // koniec odbierania
    132                  TACCR0 = receive_timeout; // zresetuj timer
    133                  TAR = 0;
    134                  ready_to_transmit = 1;
    135                }
    136                else if (r_buf_pos < 0)
    137                {
    138                  goto error;
    139                }
    140                else                    // zapisz dana do bufora
    141                {
    142                  buffer[r_buf_pos] = i_char;
    143                  r_buf_pos--;
    144                  TACCTL0 |= CCIE;      // wlacz przerwania
    145                  TACTL |= MC_2;        // continous mode on
    146                }
    147              }
    148              else if (g_flags & BIT5)    // timerA zglosil timeout, a receive milczy
    149              {
    150                receive_on = 0;           // koniec odbierania
    151                TACTL &= 0xFFCF;          // wylacz i zresetuj timerA
    152                TACCR0 = receive_timeout;
    153                TAR = 0;
    154                
    155                g_flags &= !BIT5;
    156                if (r_buf_pos != BUF_SIZE - 1)    // jesli cos odebrano
    157                {
    158                  ready_to_transmit = 1;
    159                }
    160              }
    161              
    162              /***************** rozpoczecie transmisji *****************/
    163              if ((!transmit_on) && (ready_to_transmit))
    164              {
    165                transmit_on = 1;
    166                ready_to_transmit = 0;
    167                g_t_curr_char = buffer + r_buf_pos + 1;
    168                g_t_chars_to_send = BUF_SIZE - 1 - r_buf_pos;
    169                IE1 |= UTXIE0;            // wlacz przerwania transmit
    170              }
    171              
    172              /***************** transmisja zakonczona *****************/
    173              if (g_flags & BIT4)
    174              {
    175                transmit_on = 0;
    176                g_flags &= !BIT4;
    177                r_buf_pos = BUF_SIZE - 1;
    178                IE1 &= 0x7F;              // wylacz przerwania transmit
    179                IFG1 |= UTXIFG0;          // zapewnij zgloszenie sie transmit po 
    180                                          // odblokowaniu przerwania
    181              }
    182            }
    183            
    184            /*************** obs³uga b³êdu = komunikat + reset urz¹dzenia ***************/
    185          error:
    186            __disable_interrupt();        // namieszalismy, trzeba posprzatac
    187            P1OUT |= BIT7;                // zapalenie diody bledu    
    188            
    189            // wylacz i zresetuj timerA
    190            TACTL &= 0xFFCF;              
    191            TACCR0 = receive_timeout;
    192            TAR = 0; 
    193            TACCTL0 &= 0xFFEE;            // wylacz przerwania timeraA (CCIE, CCIFG)
    194            
    195            // reset zmiennych sterujacych
    196            receive_on = 0;               
    197            transmit_on = 0;
    198            ready_to_transmit = 0;
    199            r_buf_pos = BUF_SIZE - 1;
    200            
    201            // wylaczenie przerwan receive na czas wyslania komunikatu o bledzie
    202            IE1 &= 0xBF;                  // wylacz przerwania receive
    203            // przygotowanie do wyslania
    204            g_flags = 0;
    205            g_t_curr_char = err_buf;
    206            g_t_chars_to_send = err_buf_size;
    207            IFG1 |= UTXIFG0;              // zapewnij zgloszenie sie przerwania transmit
    208            IE1 |= UTXIE0;                // wlacz przerwania transmit  
    209            
    210            // wyslanie komunikatu o bledzie
    211            __enable_interrupt();
    212            while (!(g_flags & BIT4))
    213              ;
    214            
    215            __disable_interrupt();
    216            IE1 &= 0x7F;                  // wylacz przerwania transmit
    217            IE1 |= URXIE0;                // wlacz przerwania receive
    218            IFG1 &= 0xBF;                 // skasowanie informacji o przerwaniu receive
    219            IFG1 |= UTXIFG0;              // zapewnij zgloszenie sie przerwania transmit
    220            g_flags = 0;
    221            
    222          goto mainloop;                  // petla aplikacyjna odblokuje przerwania
    223          
    224            return 0;
    225          }

   Maximum stack usage in bytes:

     Function    CSTACK
     --------    ------
     main           46
       -> strlen    46
       -> memset    46


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     _A_IE1                                    1
     _A_IFG1                                   1
     _A_ME1                                    1
     _A_WDTCTL                                 2
     _A_P1OUT                                  1
     _A_P1DIR                                  1
     _A_P3DIR                                  1
     _A_P3SEL                                  1
     _A_U0CTL                                  1
     _A_U0TCTL                                 1
     _A_U0RCTL                                 1
     U0MCTL                                    1
     U0BR0                                     1
     U0BR1                                     1
     _A_TACTL                                  2
     _A_TACCTL0                                2
     TAR                                       2
     TACCR0                                    2
     _A_BCSCTL1                                1
     _A_BCSCTL2                                1
     receive_timeout                           2
     g_r_char                                  1
     g_t_curr_char                             2
     g_t_chars_to_send                         2
     g_flags                                   2
     main                                    528
     ?<Initializer for g_r_char>               1
     ?<Constant "MSP-ERROR: device reset.">   25

 
 528 bytes in segment CODE
  25 bytes in segment DATA16_AN
  27 bytes in segment DATA16_C
   1 byte  in segment DATA16_I
   1 byte  in segment DATA16_ID
   6 bytes in segment DATA16_Z
 
 528 bytes of CODE  memory
  28 bytes of CONST memory
   7 bytes of DATA  memory (+ 25 bytes shared)

Errors: none
Warnings: 1
